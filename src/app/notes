Decorator that marks a class as an Angular component and provides configuration metadata that determines how the component should be processed, instantiated, and used at runtime.
 Components are the most basic UI building block of an Angular app. An Angular app contains a tree of Angular components.
 Angular components are a subset of directives, always associated with a template. Unlike other directives, only one component can be instantiated for a given element in a template.
 A component must belong to an NgModule in order for it to be available to another component or application. To make it a member of an NgModule, list it in the declarations field of the NgModule metadata.
 Note that, in addition to these options for configuring a directive, you can control a component's runtime behavior by implementing life-cycle hooks. 
The CSS selector that identifies this directive in a template and triggers instantiation of the directive.




[(ngModel)] is the Angular syntax to bind the food.name property to the textbox. Data flow in both directions: from the property to the textbox; and from the textbox back to the property.

Unfortunately, immediately after this change, the application breaks. If you looked in the browser console, you'd see Angular complaining that "ngModel ... isn't a known property of input."

Although NgModel is a valid Angular directive, it isn't available by default. It belongs to the optional FormsModule. You must opt-in to using that module.

The @Component decorator provides the Angular metadata for the component. The CSS selector name, food-detail, will match the element tag that identifies this component within a parent component's template.

 the parent AppComponent will tell the child FoodDetailComponent which food to display by binding its selectedFood to the food property of the FoodDetailComponent. The binding will look like this:

<food-detail [food]="selectedFood"></food-detail>
Putting square brackets around the food property, to the left of the equal sign (=), makes it the target of a property binding expression. You must declare a target binding property to be an input property.
 Otherwise, Angular rejects the binding and throws an error.

 In general, the declarations array contains a list of application components, pipes, and directives that belong to the module.
  A component must be declared in a module before other components can reference it
  Instead of copying and pasting the same code over and over, you'll create a single reusable data service and inject it into the components that need it. Using a separate service keeps components lean and focused on supporting the view, and makes it easy to unit-test components with a mock service.

Because data services are invariably asynchronous, you'll finish the page with a Promise-based version of the data service.


he naming convention for service files is the service name in lowercase followed by .service. For a multi-word service name, use lower dash-case. For example, the filename for SpecialSuperFoodService is special-super-food.service.ts.

The @Injectable() decorator tells TypeScript to emit metadata about the service. The metadata specifies that Angular may need to inject other dependencies into this service.


AppComponent should fetch and display food data with no issues.

You might be tempted to call the getFoods() method in a constructor, but a constructor should not contain complex logic, especially a constructor that calls a server, such as as a data access method. The constructor is for simple initializations, like wiring constructor parameters to properties.

To have Angular call getFoods(), you can implement the Angular ngOnInit lifecycle hook. Angular offers interfaces for tapping into critical moments in the component lifecycle: at creation, after each change, and at its eventual destruction.

Each interface has a single method. When the component implements that method, Angular calls it at the appropriate time.

When using a remote server, users don't have to wait for the server to respond; additionally,
you aren't able to block the UI during the wait.
To coordinate the view with the response, you can use Promises, 
which is an asynchronous technique that changes the signature of the getFood() method.

The hero service makes a Promise
A Promise essentially promises to call back when the results are ready.
 You ask an asynchronous service to do some work and give it a callback function.
The service does that work and eventually calls the function with the results or an error.

((look back at the service to how to see a Promice-returning method))

the caller of that asynchronous method will need to change some of the implementation
You have to change the implementation to act on the Promise when it resolves.
When the Promise resolves successfully, you'll have heroes to display.
Pass the callback function as an argument to the Promise's then() method: